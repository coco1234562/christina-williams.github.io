<!DOCTYPE html>
<html>
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script>
    /*global $*/
    const topics = ['variables', 'datatypes', 'string-manipulation', 'operators', 'control-flow', 'loops', 'functions'];
    $(document).ready(function () {
      const topicElements = topics.forEach(function (topic, index) {
        const $header = $('<h2>').addClass('topic-heading').text(topic);
        const $div = $('<div>').addClass('code').attr('id', topic).append($header);
        $.get(`./studies/${topic}.js`, function (response) {
          const split = response.split('\n');
          const $splitElements = split.map(function (line, index) {
            const $line = $('<div>').addClass('line');
            const $lineNumber = $('<div>').addClass('line-number').text(index + 1);
            const $content = $('<div>').addClass('line-content').text(line);
            return $line.append($lineNumber, $content);
          });
          $div.append($splitElements);
          $div.appendTo('.content');
        }, 'text'); // 'text' makes sure the JS file isn't executed
      });
    });
  </script>
  <link rel="stylesheet" href="./css/studies.css" type="text/css" />
  <title>Studies</title>
</head>
<body>
  <div id="all-contents">
    <nav>
      <header>Christina's Website</header>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="portfolio.html">Portfolio</a></li>
        <li><a href="studies.html">Studies</a></li>
      </ul>
    </nav>
    <main>
      <div class="content">
        <h1>Javascript</h1>

            <h1>Variables</h1>
    <p>What is a variable? A variable is a label that references a value like a number or string. Before using a variable, you need to declare it.</p>
    <p>Variables are case sensitive. That means 'christina' and 'Christina' are different variables. Variable names can only contain letters, numbers, underscores, or dollar signs and cannot contain spaces. Also, variable names must begin with a letter, an underscore (_), or a dollar sign ($). Variable names cannot use reserved words.</p>

    <h2>var</h2>
    <p>Variables declared with 'var' have a function-level scope or a global scope if declared outside of any function. They are hoisted (var declaration is moved to the top of its scope during the compilation phase). They can be redeclared and reassigned. Oldest way.</p>

    <pre>
        // Using 'var':
        var age = 25;
    </pre>

    <h2>How to assign a variable</h2>
    <p>Once you have declared a variable, you can assign it using an equal sign (=) and a value.</p>

    <pre>
        var name = 'christina';
    </pre>

    <h2>let</h2>
    <p>'let' allows you to declare block-scoped variables (ONLY accessible within the nearest enclosing block aka curly braces). It is NOT hoisted. Prevents redeclaration of the same variable.</p>

    <pre>
        let name = "John";
        name = "Alice";
    </pre>

    <pre>
        function example() {
            let x = 10;
            if (true) {
                let x = 20; // This is a new x variable, independent of the outer one
                console.log(x); // 20
            }
            console.log(x); // 10
        }
    </pre>

    <h2>const</h2>
    <p>'const' has block scope. It is used to declare variables meant to be constant (values cannot be reassigned). 'const' variables must be initialized when declared.</p>

    <pre>
        const PI = 3.14;
    </pre>

    <h2>Hoisting of a variable</h2>
    <p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>

    <pre>
        var greeter;
        console.log(greeter); // greeter is undefined
        greeter = "say hello"
    </pre>

    <h2>Data Types</h2>
    <p>JavaScript has several built-in data types. They are organized into two groups: primitive types and composite types.</p>

    <h3>Primitive Types</h3>
    <p>Numbers, String, Boolean, Null, Undefined, and Symbol.</p>

    <h2>Operators</h2>
    <p>Operators perform operations on variables and values in JavaScript.</p>

    <h3>Arithmetic operators (+, -, *, /)</h3>
    <pre>
        let x = 10;
        let y = 5;
        let sum = x + y; // Result: 15
    </pre>

    <h3>Comparison operators (==, !=, >, <, >=, <=)</h3>
    <pre>
        let a = 10;
        let b = 5;
        let isEqual = a === b; // Result: false
    </pre>

    <h3>Logical operators (&&, ||, !)</h3>
    <pre>
        let isRainy = true;
        let hasUmbrella = true;
        let takeUmbrella = isRainy && hasUmbrella; // Result: true
    </pre>

    <h2>String Manipulation</h2>
    <p>String manipulation involves changing or combining strings in JavaScript.</p>

    <h3>Concatenation</h3>
    <pre>
        let firstName = "John";
        let lastName = "Doe";
        let fullName = firstName + " " + lastName; // Result: "John Doe"
    </pre>

    <h3>String length</h3>
    <pre>
        let message = "Hello, World!";
        let length = message.length; // Result: 13
    </pre>

    <h3>Substring</h3>
    <pre>
        let sentence = "The quick brown fox";
        let substring = sentence.substring(4, 9); // Result: "quick"
    </pre>

    <h2>Control Flow</h2>
    <p>Control flow allows you to make decisions in your code using 'if', 'else if', and 'else' statements.</p>

    <h3>if statement</h3>
    <pre>
        let age = 18;
        if (age >= 18) {
            console.log("You are an adult.");
        } else {
            console.log("You are a minor.");
        }
    </pre>

    <h3>else if statement</h3>
    <pre>
        let score = 85;
        if (score >= 90) {
            console.log("A");
        } else if (score >= 80) {
            console.log("B");
        } else {
            console.log("C");
        }
    </pre>

    <h3>switch statement</h3>
    <pre>
        let day = "Monday";
        switch (day) {
            case "Monday":
                console.log("Start of the workweek");
                break;
            case "Friday":
                console.log("End of the workweek");
                break;
            default:
                console.log("Regular workday");
        }
    </pre>

    <h2>Loops</h2>
    <p>Loops are used to repeatedly execute a block of code until a condition is met.</p>

    <h3>for loop</h3>
    <pre>
        for (let i = 0; i < 5; i++) {
            console.log(i); // Output: 0, 1, 2, 3, 4
        }
    </pre>

    <h3>while loop</h3>
    <pre>
        let count = 1;
        while (count <= 5) {
            console.log(count); // Output: 1, 2, 3, 4, 5
            count++;
        }
    </pre>

    <h3>do-while loop</h3>
    <pre>
        let num = 1;
        do {
            console.log(num); // Output: 1
            num++;
        } while (num <= 0);
    </pre>

    <h2>Functions</h2>
    <p>Functions are blocks of reusable code that can be called with arguments and return values.</p>

    <h3>Function with parameters and a return value</h3>
    <pre>
        function addNumbers(a, b) {
            return a + b;
        }
        let result = addNumbers(5, 10); // Result: 15
    </pre>

    <h3>Function without parameters</h3>
    <pre>
        function greet() {
            console.log("Hello!");
        }
        greet(); // Output: "Hello!"
    </pre>

    <h3>Arrow function (ES6 syntax)</h3>
    <pre>
        const multiply = (a, b) => a * b;
        let product = multiply(3, 4); // Result: 12
    </pre>

        <h1>Functions</h1>
    <ol>
        <li>The two phases to using functions are:</li>
        <ul>
            <li>Function declaration: In this phase, we define the function with its name, parameters, and the code that it will execute when called.</li>
            <li>Function invocation or execution: In this phase, we call or execute the function, passing any required arguments, and the code inside the function's body is executed.</li>
        </ul>

        <li>What's the difference between a function's parameters and arguments PASSED to a function?</li>
        <p>Parameters are placeholders or variables defined in the function's declaration that represent the values that the function expects to receive when it is called. Arguments are the actual values passed to the function when it is called. These values are assigned to the corresponding parameters in the function's declaration.</p>

        <li>What's the syntax for a NAMED function?</li>
        <pre>
            function functionName(parameter1, parameter2) {
                // Function code goes here
            }
        </pre>

        <li>How do we assign a function to a variable?</li>
        <pre>
            const myFunction = function(parameter1, parameter2) {
                // Function code goes here
            };
        </pre>

        <li>Functions can OPTIONALLY take inputs, and OPTIONALLY return a single value. How do we specify inputs, and how do we specify outputs?</li>
        <p>Inputs (arguments) are specified when calling the function. For example, if a function has parameters `x` and `y`, you would call it with `myFunction(10, 20)`, where `10` and `20` are the inputs passed to the function.</p>
        <p>Outputs are specified using the `return` statement within the function. For example:</p>
        <pre>
            function addNumbers(a, b) {
                return a + b;
            }
        </pre>
        <p>In this example, the function `addNumbers` takes two inputs `a` and `b`, and it returns their sum as the output.</p>

        <li>Scope:</li>
        <p>Functions can access and modify variables in their parent or global scopes. However, variables declared within a function are not accessible outside the function's scope, which means the inverse is not true. Variables defined outside the function are accessible within the function (unless there are variables with the same name defined inside the function, which would create a new local scope).</p>

        <li>Closures:</li>
        <p>Closures occur when a function "remembers" its lexical scope even when the function is executed outside that scope. This means that if a function returns another function or if an inner function is referenced and held in memory somewhere, it retains access to the variables and data in its outer function's scope. The outer function's scope becomes a part of the closure, allowing the inner function to access and use those variables even after the outer function has finished executing. This behavior enables data to persist within closures even if the original function has completed its execution.</p>



      
      </div>
    </main>
  </div>
</body>
</html>
